class MinimalInfiniteSlider { constructor(t) { this.container = document.getElementById(t.containerId), this.content = document.getElementById(t.contentId), this.nextBtn = document.getElementById(t.nextId), this.prevBtn = document.getElementById(t.prevId), this.speed = t.speed || 1, this.gap = t.gap || 30, this.itemWidth = t.itemWidth || 100, this.pauseOnHover = !1 !== t.pauseOnHover, this.isAnimating = !0, this.isPaused = !1, this.animationId = null, this.currentTranslate = 0, this.isDragging = !1, this.startX = 0, this.currentX = 0, this.dragOffset = 0, this.init() } init() { this.setupInfiniteLoop(), this.setupEventListeners(), this.start() } setupInfiniteLoop() { var t = Array.from(this.content.children); 0 !== t.length && (t.map(t => t.cloneNode(!0)).forEach(t => this.content.appendChild(t)), this.singleWidth = t.length * (this.itemWidth + this.gap), this.currentTranslate = 0, this.content.style.transform = `translateX(${this.currentTranslate}px)`, this.content.style.transition = "none") } setupEventListeners() { this.pauseOnHover && (this.container.addEventListener("mouseenter", () => this.pause()), this.container.addEventListener("mouseleave", () => this.resume())), this.container.addEventListener("mousedown", t => this.startDrag(t)), this.container.addEventListener("touchstart", t => this.startDrag(t), { passive: !1 }), document.addEventListener("mousemove", t => this.drag(t)), document.addEventListener("touchmove", t => this.drag(t), { passive: !1 }), document.addEventListener("mouseup", () => this.endDrag()), document.addEventListener("touchend", () => this.endDrag()), this.nextBtn && this.nextBtn.addEventListener("click", () => this.next()), this.prevBtn && this.prevBtn.addEventListener("click", () => this.prev()), document.addEventListener("visibilitychange", () => { document.hidden ? this.pause() : this.resume() }) } startDrag(t) { this.isDragging = !0, this.startX = (t.type.includes("touch") ? t.touches[0] : t).clientX, this.currentX = this.startX, this.dragOffset = 0, this.pause(), this.container.style.cursor = "grabbing", t.preventDefault() } drag(t) { var e; this.isDragging && (this.currentX = (t.type.includes("touch") ? t.touches[0] : t).clientX, this.dragOffset = this.currentX - this.startX, e = this.currentTranslate + this.dragOffset, this.content.style.transform = `translateX(${e}px)`, t.preventDefault()) } endDrag() { this.isDragging && (this.isDragging = !1, this.currentTranslate += this.dragOffset, this.dragOffset = 0, this.container.style.cursor = "grab", setTimeout(() => this.resume(), 300)) } next() { this.pause(); var t = this.itemWidth + this.gap; this.smoothMove(-t), setTimeout(() => this.resume(), 600) } prev() { this.pause(); var t = this.itemWidth + this.gap; this.smoothMove(t), setTimeout(() => this.resume(), 600) } smoothMove(s) { let i = this.currentTranslate; i; let n = 500, r = performance.now(), a = t => { var t = t - r, t = Math.min(t / n, 1), e = 1 - Math.pow(1 - t, 3), e = i + s * e; this.currentTranslate = e, this.content.style.transform = `translateX(${e}px)`, t < 1 ? requestAnimationFrame(a) : this.checkReset() }; requestAnimationFrame(a) } animate() { !this.isAnimating || this.isPaused || this.isDragging || (this.currentTranslate -= this.speed, this.content.style.transform = `translateX(${this.currentTranslate}px)`, this.checkReset()), this.animationId = requestAnimationFrame(() => this.animate()) } checkReset() { this.currentTranslate <= -this.singleWidth && (this.currentTranslate += this.singleWidth), 0 < this.currentTranslate && (this.currentTranslate -= this.singleWidth) } start() { this.isAnimating = !0, this.isPaused = !1, this.container.style.cursor = "grab", this.animate() } pause() { this.isPaused = !0 } resume() { this.isPaused = !1 } stop() { this.isAnimating = !1, this.animationId && cancelAnimationFrame(this.animationId) } updateSpeed(t) { this.speed = Math.max(.5, Math.min(5, t)) } destroy() { this.stop(), this.isDragging = !1, this.content.style.transform = "", this.content.style.transition = "" } } let sliderInstances = {}; function createSlider(t, e) { return sliderInstances[t] && sliderInstances[t].destroy(), sliderInstances[t] = new MinimalInfiniteSlider(e), sliderInstances[t] } function getResponsiveConfig() { var t = window.innerWidth; return t <= 500 ? { speed: 1, gap: 28, itemWidth: 85 } : t <= 620 ? { speed: 1.2, gap: 30, itemWidth: 100 } : t <= 800 ? { speed: 1.2, gap: 40, itemWidth: 100 } : t <= 1200 ? { speed: 1.4, gap: 80, itemWidth: 130 } : { speed: 1.2, gap: 115, itemWidth: 155 } } function initializeSlider() { document.getElementById("carousel") && createSlider("logoSlider", { containerId: "carousel", contentId: "content", nextId: "next", prevId: "prev", ...getResponsiveConfig(), pauseOnHover: !0 }) } let resizeTimeout; window.addEventListener("resize", () => { clearTimeout(resizeTimeout), resizeTimeout = setTimeout(() => { var t, e = sliderInstances.logoSlider; e && (t = getResponsiveConfig(), e.updateSpeed(t.speed)) }, 250) }), "loading" === document.readyState ? document.addEventListener("DOMContentLoaded", initializeSlider) : initializeSlider(), window.pauseSlider = () => { Object.values(sliderInstances).forEach(t => t.pause()) }, window.resumeSlider = () => { Object.values(sliderInstances).forEach(t => t.resume()) }, window.updateSliderSpeed = e => { Object.values(sliderInstances).forEach(t => t.updateSpeed(e)) };